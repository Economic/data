---
title: Available data
format: 
  html:
    page-layout: full
params:
  meta: "NA"
execute:
  echo: false
---
```{r}
#| include: false
#| message: false
library(tidyverse)
library(targets)
library(kableExtra)
library(reactable)
library(htmltools)

batch_id <- params$meta

data_id_vars <- c(
  "indicator_name", 
  "measure_name", 
  "geo_cat", 
  "date_interval", 
  "dimension_value_names", 
  "dimension_names"
)

concise_data <- tar_read(all_stats) |> 
  mutate(date = ymd(date)) |> 
  mutate(geo_cat = case_match(geo_id, 0 ~ "National", .default = "State")) |> 
  mutate(
    min_date = min(date), max_date = max(date), 
    .by = all_of(data_id_vars)
  ) |> 
  distinct(pick(all_of(data_id_vars)), .keep_all = TRUE) |> 
  mutate(dates = case_match(
    date_interval,
    "year" ~ paste0(year(min_date), "-", year(max_date)),
    "month" ~ paste0(format(min_date, "%b %Y"), "-", format(max_date, "%b %Y")),
    "quarter" ~ paste0(
      year(min_date), "q", quarter(min_date), "-",
      year(max_date), "q", quarter(max_date)
    )
  )) |> 
  mutate(frequency = case_match(
    date_interval,
    "year" ~ "Annual",
    "month" ~ "Monthly",
    "quarter" ~ "Quarterly"
  )) |> 
  group_by(indicator_name, measure_name, geo_cat, dimension_value_names) |> 
  summarize(dates = str_c(dates, collapse = ", "), .groups = "drop")

```

Data for release Version `{r} batch_id`:

```{r}
data <- concise_data

# Select input filter with an "All" default option
selectFilter <- function(tableId, style = "width: 100%; height: 100%;") {
  function(values, name) {
    tags$select(
      # Set to undefined to clear the filter
      onchange = sprintf("
        const value = event.target.value
        Reactable.setFilter('%s', '%s', value === '__ALL__' ? undefined : value)
      ", tableId, name),
      # "All" has a special value to clear the filter, and is the default option
      tags$option(value = "__ALL__", "All"),
      lapply(unique(values), tags$option),
      "aria-label" = sprintf("Filter %s", name),
      style = style
    )
  }
}

# Min range filter input that handles NaNs
minRangeFilter <- function(tableId, style = "width: 100%;") {
  function(values, name) {
    values <- na.omit(values)
    oninput <- sprintf("Reactable.setFilter('%s', '%s', this.value)", tableId, name)
    tags$input(
      type = "range",
      min = floor(min(values)),
      max = ceiling(max(values)),
      value = floor(min(values)),
      oninput = oninput,
      style = style,
      "aria-label" = sprintf("Filter by minimum %s", name)
    )
  }
}

# Min value filter method that handles NaNs
filterMinValue <- JS("(rows, columnId, filterValue) => {
  return rows.filter(row => {
    const value = row.values[columnId]
    return !isNaN(value) && value >= filterValue
  })
}")

reactable(
  data,
  columns = list(
    indicator_name = colDef(
      name = "Indicator",
      filterInput = selectFilter("tbl-input"),
      width = 200
    ),
    measure_name = colDef(
      name = "Measure",
      filterInput = selectFilter("tbl-input"),
      width = 350
    ),
    geo_cat = colDef(
      name = "Geography",
      filterInput = selectFilter("tbl-input"),
      width = 100
    ),
    dimension_value_names = colDef(
      name = "Dimensions",
      filterInput = selectFilter("tbl-input")
    ),
    dates = colDef(
      name = "Availability",
      filterable = FALSE,
    )
  ),
  filterable = TRUE,
  wrap = TRUE,
  resizable = TRUE,
  pagination = FALSE,
  elementId = "tbl-input"
)
```



